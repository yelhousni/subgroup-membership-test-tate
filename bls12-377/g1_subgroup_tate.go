package bls12377

import (
	curve "github.com/consensys/gnark-crypto/ecc/bls12-377"
	"github.com/consensys/gnark-crypto/ecc/bls12-377/fp"
)

// IsInSubGroupTate checks whether p is in the correct subgroup using the
// Tate-based test with precomputation.
//
// It follows "Revisiting subgroup membership testing on pairing-friendly
// curves via the Tate pairing" by Y. Dai et al.
// https://eprint.iacr.org/2024/1790.pdf (Alg.4 and 5).
func IsInSubGroupTate(tab loopkupTable, p *curve.G1Affine) bool {
	if p.IsInfinity() {
		return false
	}
	if !p.IsOnCurve() {
		return false
	}
	return membershipTest(p, &tab.q, tab.tab)
}

// membershipTest performs Algorithm 5.
func membershipTest(p, q *curve.G1Affine, tab []fp.Element) bool {

	var thirdRootOneG1 fp.Element
	thirdRootOneG1.SetString("80949648264912719408558363140637477264845294720710499478137287262712535938301461879813459410945")

	// Step 1: Algorithm 4.
	var p2 /* phi(p) */ curve.G1Affine
	p2.X.Mul(&p.X, &thirdRootOneG1)
	p2.Y.Set(&p.Y)

	var n1, d1, n2, d2 fp.Element
	n1.Sub(&p.X, &q.X)
	n2.Sub(&p2.X, &q.X)
	d1.SetOne()
	d2.SetOne()
	// shared Miller loop with precomputation
	sharedMillerloop(tab, &n1, &d1, &n2, &d2, q, p, &p2)

	if n1.IsZero() || d1.IsZero() || n2.IsZero() || d2.IsZero() {
		return false
	}

	// steps 5-8: simultaneous inversion and final exponentiations.
	n1.Mul(&n1, &d2)
	n2.Mul(&n2, &d1)
	d1.Mul(&d1, &d2)
	d1.Inverse(&d1)
	n1.Mul(&n1, &d1)
	n2.Mul(&n2, &d1)

	return f1IsOne(&n1) && f2IsOne(&n2)
}

func sharedMillerloop(tab []fp.Element, n1, d1, n2, d2 *fp.Element, q, p, p2 *curve.G1Affine) {
	i := 63
	j := 0
	k := 0
	if naf[0] < 0 {
		j = 1
	}

	var f1, g1, f2, g2 fp.Element
	var u0, u1, u2, u3 fp.Element
	var v0, v1, v2 fp.Element

	u1.Sub(&p.Y, &q.Y)
	u2.Sub(&p.X, &q.X)
	u3.Sub(&p2.X, &q.X)

	for i >= j {
		if naf[i] == 0 && i > j {
			u0.Sub(&p.Y, &tab[k+2])
			f1.Sub(&p.X, &tab[k+1])
			f2.Sub(&p2.X, &tab[k+1])
			g1.Mul(&f1, &tab[k])
			g1.Sub(&u0, &g1)
			g2.Mul(&f2, &tab[k])
			g2.Sub(&u0, &g2)
			f1.Mul(&f1, &tab[k+3])
			f1.Sub(&u0, &f1)
			f2.Mul(&f2, &tab[k+3])
			f2.Sub(&u0, &f2)

			n1.Square(n1)
			n1.Square(n1)
			n1.Mul(n1, &f1)
			d1.Square(d1)
			d1.Mul(d1, &g1)
			d1.Square(d1)

			n2.Square(n2)
			n2.Square(n2)
			n2.Mul(n2, &f2)
			d2.Square(d2)
			d2.Mul(d2, &g2)
			d2.Square(d2)

			k += 4
			i--

			if naf[i] > 0 {
				f1.Mul(&tab[k], &u2)
				f1.Sub(&u1, &f1)
				f2.Mul(&tab[k], &u3)
				f2.Sub(&u1, &f2)
				g1.Sub(&p.X, &tab[k+1])
				g2.Sub(&p2.X, &tab[k+1])

				n1.Mul(n1, &f1)
				d1.Mul(d1, &g1)
				n2.Mul(n2, &f2)
				d2.Mul(d2, &g2)
				k += 2
			}

			if naf[i] < 0 {
				f1.Sub(&p.X, &tab[k+1])
				f2.Sub(&p2.X, &tab[k+1])
				g1.Mul(&tab[k], &u2)
				g1.Sub(&u1, &g1)
				g2.Mul(&tab[k], &u3)
				g2.Sub(&u1, &g2)

				n1.Mul(n1, &f1)
				d1.Mul(d1, &g1)
				n2.Mul(n2, &f2)
				d2.Mul(d2, &g2)
				k += 2
			}
			i--
			continue
		}

		if naf[i] == 1 || naf[i] == -1 {
			u0.Sub(&p.X, &tab[k])
			g1.Sub(&p2.X, &tab[k])
			g2.Add(&p.X, &tab[k+2])
			f1.Add(&p2.X, &tab[k+2])
			v0.Mul(&u0, &g2)
			v1.Mul(&g1, &f1)
			g2.Sub(&p.Y, &tab[k+1])
			v2.Mul(&g2, &tab[k+3])
			v0.Sub(&v0, &v2)
			v1.Sub(&v1, &v2)
			f1.Set(&v0)
			f2.Set(&v1)

			n1.Square(n1)
			n1.Mul(n1, &f1)
			d1.Mul(d1, &u0)
			d1.Square(d1)

			n2.Square(n2)
			n2.Mul(n2, &f2)
			d2.Mul(d2, &g1)
			d2.Square(d2)
			if naf[i] < 0 {
				d1.Mul(d1, &u2)
				d2.Mul(d2, &u3)
			}

			k += 4
			i--
			continue
		}

		f1.Sub(&p.X, &tab[k+1])
		f2.Sub(&p2.X, &tab[k+1])
		u0.Sub(&p.Y, &tab[k+2])
		g1.Mul(&tab[k], &f1)
		g1.Sub(&u0, &g1)
		g2.Mul(&tab[k], &f2)
		g2.Sub(&u0, &g2)

		n1.Square(n1)
		n1.Mul(n1, &f1)
		d1.Square(d1)
		d1.Mul(d1, &g1)
		n2.Square(n2)
		n2.Mul(n2, &f2)
		d2.Square(d2)
		d2.Mul(d2, &g2)

		k += 3
		i--
	}

	if naf[0] < 0 {
		g1.Sub(&p.X, &tab[k])
		g2.Sub(&p2.X, &tab[k])
		n1.Square(n1)
		d1.Square(d1)
		d1.Mul(d1, &g1)
		n2.Square(n2)
		d2.Square(d2)
		d2.Mul(d2, &g2)
	}
}

// f2IsOne raises x to exp2 = |z^5-z^4-z^3+z^2+z+2| and checks if the result is 1
func f2IsOne(x *fp.Element) bool {
	var u0, u1, u2, u3 fp.Element

	// Section 4.3: exp2 final exponentiation for the Tate test.
	u0.Square(x)
	expBySeed(&u1, x)
	expBySeed(&u2, &u1)
	expBySeed(&u3, &u2)
	u0.Mul(&u0, &u2)
	u0.Mul(&u0, &u3)
	expBySeed(&u3, &u3)
	u1.Mul(&u1, &u3)
	expBySeed(&u3, &u3)
	u1.Mul(&u1, &u3)

	return u0.Equal(&u1)
}

// expBySeed computes z = x^z where z = 0x8508c00000000001
func expBySeed(z, x *fp.Element) {
	// Operations: 61 squares 7 multiplies
	//
	// Generated by github.com/mmcloughlin/addchain v0.4.0.

	// Allocate Temporaries.
	var (
		t0 = new(fp.Element)
		t1 = new(fp.Element)
	)

	// Step 1: z = x^0x2
	z.Square(x)

	// Step 2: z = x^0x3
	z.Mul(x, z)

	// Step 3: z = x^0x6
	z.Square(z)

	// Step 4: z = x^0x7
	z.Mul(x, z)

	// Step 6: t0 = x^0x1c
	t0.Square(z)
	for s := 1; s < 2; s++ {
		t0.Square(t0)
	}

	// Step 7: z = x^0x23
	z.Mul(z, t0)

	// Step 8: t1 = x^0x46
	t1.Square(z)

	// Step 9: t1 = x^0x69
	t1.Mul(z, t1)

	// Step 10: t0 = x^0x85
	t0.Mul(t0, t1)

	// Step 20: t0 = x^0x21400
	for s := 0; s < 10; s++ {
		t0.Square(t0)
	}

	// Step 21: z = x^0x21423
	z.Mul(z, t0)

	// Step 67: z = x^0x8508c00000000000
	for s := 0; s < 46; s++ {
		z.Square(z)
	}

	// Step 68: z = x^0x8508c00000000001
	z.Mul(x, z)
}

// f1IsOne raises x to exp1 = (p-1)/e2 and checks if the result is 1
func f1IsOne(x *fp.Element) bool {
	// Operations: 308 squares 55 multiplies
	//
	// Generated by github.com/mmcloughlin/addchain v0.4.0.

	// Allocate Temporaries.
	var z = new(fp.Element)
	var (
		t0  = new(fp.Element)
		t1  = new(fp.Element)
		t2  = new(fp.Element)
		t3  = new(fp.Element)
		t4  = new(fp.Element)
		t5  = new(fp.Element)
		t6  = new(fp.Element)
		t7  = new(fp.Element)
		t8  = new(fp.Element)
		t9  = new(fp.Element)
		t10 = new(fp.Element)
		t11 = new(fp.Element)
		t12 = new(fp.Element)
		t13 = new(fp.Element)
		t14 = new(fp.Element)
		t15 = new(fp.Element)
		t16 = new(fp.Element)
		t17 = new(fp.Element)
		t18 = new(fp.Element)
	)

	// Step 1: t9 = x^0x2
	t9.Square(x)

	// Step 2: t0 = x^0x3
	t0.Mul(x, t9)

	// Step 3: t8 = x^0x4
	t8.Mul(x, t0)

	// Step 4: t3 = x^0x6
	t3.Mul(t9, t8)

	// Step 5: t15 = x^0x7
	t15.Mul(x, t3)

	// Step 6: z = x^0xb
	z.Mul(t8, t15)

	// Step 7: t5 = x^0xd
	t5.Mul(t9, z)

	// Step 8: t1 = x^0x11
	t1.Mul(t8, t5)

	// Step 9: t12 = x^0x13
	t12.Mul(t9, t1)

	// Step 10: t4 = x^0x17
	t4.Mul(t8, t12)

	// Step 11: t10 = x^0x19
	t10.Mul(t9, t4)

	// Step 12: t2 = x^0x1d
	t2.Mul(t8, t10)

	// Step 13: t6 = x^0x1f
	t6.Mul(t9, t2)

	// Step 14: t16 = x^0x25
	t16.Mul(t3, t6)

	// Step 15: t14 = x^0x27
	t14.Mul(t9, t16)

	// Step 16: t7 = x^0x29
	t7.Mul(t9, t14)

	// Step 17: t3 = x^0x2d
	t3.Mul(t8, t7)

	// Step 18: t17 = x^0x2f
	t17.Mul(t9, t3)

	// Step 19: t11 = x^0x33
	t11.Mul(t8, t17)

	// Step 20: t13 = x^0x35
	t13.Mul(t9, t11)

	// Step 21: t8 = x^0x37
	t8.Mul(t9, t13)

	// Step 22: t18 = x^0x66
	t18.Mul(t17, t8)

	// Step 27: t18 = x^0xcc0
	for s := 0; s < 5; s++ {
		t18.Square(t18)
	}

	// Step 28: t17 = x^0xcef
	t17.Mul(t17, t18)

	// Step 34: t17 = x^0x33bc0
	for s := 0; s < 6; s++ {
		t17.Square(t17)
	}

	// Step 35: t16 = x^0x33be5
	t16.Mul(t16, t17)

	// Step 47: t16 = x^0x33be5000
	for s := 0; s < 12; s++ {
		t16.Square(t16)
	}

	// Step 48: t16 = x^0x33be501f
	t16.Mul(t6, t16)

	// Step 54: t16 = x^0xcef9407c0
	for s := 0; s < 6; s++ {
		t16.Square(t16)
	}

	// Step 55: t16 = x^0xcef9407d1
	t16.Mul(t1, t16)

	// Step 59: t16 = x^0xcef9407d10
	for s := 0; s < 4; s++ {
		t16.Square(t16)
	}

	// Step 60: t15 = x^0xcef9407d17
	t15.Mul(t15, t16)

	// Step 69: t15 = x^0x19df280fa2e00
	for s := 0; s < 9; s++ {
		t15.Square(t15)
	}

	// Step 70: t15 = x^0x19df280fa2e29
	t15.Mul(t7, t15)

	// Step 78: t15 = x^0x19df280fa2e2900
	for s := 0; s < 8; s++ {
		t15.Square(t15)
	}

	// Step 79: t14 = x^0x19df280fa2e2927
	t14.Mul(t14, t15)

	// Step 86: t14 = x^0xcef9407d17149380
	for s := 0; s < 7; s++ {
		t14.Square(t14)
	}

	// Step 87: t13 = x^0xcef9407d171493b5
	t13.Mul(t13, t14)

	// Step 92: t13 = x^0x19df280fa2e29276a0
	for s := 0; s < 5; s++ {
		t13.Square(t13)
	}

	// Step 93: t13 = x^0x19df280fa2e29276bd
	t13.Mul(t2, t13)

	// Step 100: t13 = x^0xcef9407d171493b5e80
	for s := 0; s < 7; s++ {
		t13.Square(t13)
	}

	// Step 101: t13 = x^0xcef9407d171493b5e97
	t13.Mul(t4, t13)

	// Step 107: t13 = x^0x33be501f45c524ed7a5c0
	for s := 0; s < 6; s++ {
		t13.Square(t13)
	}

	// Step 108: t12 = x^0x33be501f45c524ed7a5d3
	t12.Mul(t12, t13)

	// Step 113: t12 = x^0x677ca03e8b8a49daf4ba60
	for s := 0; s < 5; s++ {
		t12.Square(t12)
	}

	// Step 114: t12 = x^0x677ca03e8b8a49daf4ba6d
	t12.Mul(t5, t12)

	// Step 123: t12 = x^0xcef9407d171493b5e974da00
	for s := 0; s < 9; s++ {
		t12.Square(t12)
	}

	// Step 124: t11 = x^0xcef9407d171493b5e974da33
	t11.Mul(t11, t12)

	// Step 130: t11 = x^0x33be501f45c524ed7a5d368cc0
	for s := 0; s < 6; s++ {
		t11.Square(t11)
	}

	// Step 131: t10 = x^0x33be501f45c524ed7a5d368cd9
	t10.Mul(t10, t11)

	// Step 141: t10 = x^0xcef9407d171493b5e974da336400
	for s := 0; s < 10; s++ {
		t10.Square(t10)
	}

	// Step 142: t10 = x^0xcef9407d171493b5e974da336437
	t10.Mul(t8, t10)

	// Step 151: t10 = x^0x19df280fa2e29276bd2e9b466c86e00
	for s := 0; s < 9; s++ {
		t10.Square(t10)
	}

	// Step 152: t9 = x^0x19df280fa2e29276bd2e9b466c86e02
	t9.Mul(t9, t10)

	// Step 153: t8 = x^0x19df280fa2e29276bd2e9b466c86e39
	t8.Mul(t8, t9)

	// Step 160: t8 = x^0xcef9407d171493b5e974da3364371c80
	for s := 0; s < 7; s++ {
		t8.Square(t8)
	}

	// Step 161: t7 = x^0xcef9407d171493b5e974da3364371ca9
	t7.Mul(t7, t8)

	// Step 166: t7 = x^0x19df280fa2e29276bd2e9b466c86e39520
	for s := 0; s < 5; s++ {
		t7.Square(t7)
	}

	// Step 167: t6 = x^0x19df280fa2e29276bd2e9b466c86e3953f
	t6.Mul(t6, t7)

	// Step 178: t6 = x^0xcef9407d171493b5e974da3364371ca9f800
	for s := 0; s < 11; s++ {
		t6.Square(t6)
	}

	// Step 179: t6 = x^0xcef9407d171493b5e974da3364371ca9f81d
	t6.Mul(t2, t6)

	// Step 185: t6 = x^0x33be501f45c524ed7a5d368cd90dc72a7e0740
	for s := 0; s < 6; s++ {
		t6.Square(t6)
	}

	// Step 186: t6 = x^0x33be501f45c524ed7a5d368cd90dc72a7e0757
	t6.Mul(t4, t6)

	// Step 192: t6 = x^0xcef9407d171493b5e974da3364371ca9f81d5c0
	for s := 0; s < 6; s++ {
		t6.Square(t6)
	}

	// Step 193: t6 = x^0xcef9407d171493b5e974da3364371ca9f81d5dd
	t6.Mul(t2, t6)

	// Step 199: t6 = x^0x33be501f45c524ed7a5d368cd90dc72a7e0757740
	for s := 0; s < 6; s++ {
		t6.Square(t6)
	}

	// Step 200: t6 = x^0x33be501f45c524ed7a5d368cd90dc72a7e0757751
	t6.Mul(t1, t6)

	// Step 208: t6 = x^0x33be501f45c524ed7a5d368cd90dc72a7e075775100
	for s := 0; s < 8; s++ {
		t6.Square(t6)
	}

	// Step 209: t6 = x^0x33be501f45c524ed7a5d368cd90dc72a7e075775117
	t6.Mul(t4, t6)

	// Step 215: t6 = x^0xcef9407d171493b5e974da3364371ca9f81d5dd445c0
	for s := 0; s < 6; s++ {
		t6.Square(t6)
	}

	// Step 216: t5 = x^0xcef9407d171493b5e974da3364371ca9f81d5dd445cd
	t5.Mul(t5, t6)

	// Step 233: t5 = x^0x19df280fa2e29276bd2e9b466c86e3953f03abba88b9a0000
	for s := 0; s < 17; s++ {
		t5.Square(t5)
	}

	// Step 234: t4 = x^0x19df280fa2e29276bd2e9b466c86e3953f03abba88b9a0017
	t4.Mul(t4, t5)

	// Step 244: t4 = x^0x677ca03e8b8a49daf4ba6d19b21b8e54fc0eaeea22e68005c00
	for s := 0; s < 10; s++ {
		t4.Square(t4)
	}

	// Step 245: t3 = x^0x677ca03e8b8a49daf4ba6d19b21b8e54fc0eaeea22e68005c2d
	t3.Mul(t3, t4)

	// Step 251: t3 = x^0x19df280fa2e29276bd2e9b466c86e3953f03abba88b9a00170b40
	for s := 0; s < 6; s++ {
		t3.Square(t3)
	}

	// Step 252: t2 = x^0x19df280fa2e29276bd2e9b466c86e3953f03abba88b9a00170b5d
	t2.Mul(t2, t3)

	// Step 258: t2 = x^0x677ca03e8b8a49daf4ba6d19b21b8e54fc0eaeea22e68005c2d740
	for s := 0; s < 6; s++ {
		t2.Square(t2)
	}

	// Step 259: t1 = x^0x677ca03e8b8a49daf4ba6d19b21b8e54fc0eaeea22e68005c2d751
	t1.Mul(t1, t2)

	// Step 265: t1 = x^0x19df280fa2e29276bd2e9b466c86e3953f03abba88b9a00170b5d440
	for s := 0; s < 6; s++ {
		t1.Square(t1)
	}

	// Step 266: t0 = x^0x19df280fa2e29276bd2e9b466c86e3953f03abba88b9a00170b5d443
	t0.Mul(t0, t1)

	// Step 301: t0 = x^0xcef9407d171493b5e974da3364371ca9f81d5dd445cd000b85aea21800000000
	for s := 0; s < 35; s++ {
		t0.Square(t0)
	}

	// Step 302: t0 = x^0xcef9407d171493b5e974da3364371ca9f81d5dd445cd000b85aea2180000000b
	t0.Mul(z, t0)

	// Step 309: t0 = x^0x677ca03e8b8a49daf4ba6d19b21b8e54fc0eaeea22e68005c2d7510c0000000580
	for s := 0; s < 7; s++ {
		t0.Square(t0)
	}

	// Step 310: z = x^0x677ca03e8b8a49daf4ba6d19b21b8e54fc0eaeea22e68005c2d7510c000000058b
	z.Mul(z, t0)

	// Step 315: z = x^0xcef9407d171493b5e974da3364371ca9f81d5dd445cd000b85aea2180000000b160
	for s := 0; s < 5; s++ {
		z.Square(z)
	}

	// Step 316: z = x^0xcef9407d171493b5e974da3364371ca9f81d5dd445cd000b85aea2180000000b161
	z.Mul(x, z)

	// Step 362: z = x^0x33be501f45c524ed7a5d368cd90dc72a7e07577511734002e16ba88600000002c58400000000000
	for s := 0; s < 46; s++ {
		z.Square(z)
	}

	// Step 363: z = x^0x33be501f45c524ed7a5d368cd90dc72a7e07577511734002e16ba88600000002c58400000000001
	z.Mul(x, z)

	return z.IsOne()
}
